# 1 数据库原理

## 1.1 事务

### 1.1.1 事务的概念

事务是一组**原子性的 SQL 查询，或者说一个独立的工作单元**。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行成功，要么全部执行失败。

事务满足ACID特性。事务既可以提交（Commit），也可以回滚（Rollback）。

### 1.1.2 ACID

事务的ACID特性：

（1）原子性（Atomicity）：事务被视为不可分割的最小单元，对事务的所有操作要么成功提交，要门失败回滚。

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

（2）一致性（Consistency）：事务总是从一个一致性状态转换到另一个一致性状态。

在事务开始之前和事务结束以后，数据库的**完整性**没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。

（3）隔离性（Isolation）：在**无并发**的情况下，一个事务所做的修改在最终提交以前，对其它事务是不可见的。

（4）持久性（Durability）：一旦事务成功提交，则其所作的修改将会永远地保存到数据库中，即使**系统发生崩溃**事务执行的结果也不能丢失。

系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

## 1.2 并发一致性问题

在并发的情况下，事务难以保证**隔离性**，导致出现了很多**并发一致性问题**，即不同事务同同一个数据的读取结果可能不同。

产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

### 1.2.1 脏读

**脏读**（Dirty Read）：指在不同的事务下，当前事务读到另外事务未提交的数据。

例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

### 1.2.2 不可重复读

指**一个事务内**多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。

例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

### 1.2.3 幻读

幻读本质上也属于不可重复读的情况。T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

## 1.3 隔离级别

### 1.3.1 读未提交

READ UNCOM的MITTED。事务中修改，即使未提交，对其它事务也是可见的。

### 1.3.2 读已提交

READ COMMITTED。一个事务只能读取已经提交的事务所作的修改，事务在未提交的状态下对其它事务是不可见的。

### 1.3.3  可重复读

REPEATABLE READ。保证同一个事务中多次读取同一数据的结果是一样的。

### 1.3.4 可串行化

SERIALIZABLE。强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

## 1.4 封锁

### 1.4.1 封锁粒度

MySQL提供了两种封锁粒度，行级锁以及表级锁。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

### 1.4.2 封锁类型

封锁主要分为两个类型：读写锁和意向锁。

（1）读写锁

- 共享锁（shared）：读锁，s锁。只能对数据进行读操作，不能更新数据。s锁期间，其它事务也只能对同一数据加s锁。
- 互斥锁（exclusive）：写锁，x锁。对数据进行读取和更新操作。x锁期间，其它事务不能对该数据上锁。

（2）意向锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在**行级锁和表级锁**的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示**一个事务想要在表中的某个数据行上加 X 锁或 S 锁**。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

### 1.4.3 封锁协议

（1）三级封锁协议

（2）两段锁协议：加锁和解锁分为两个阶段进行。

MySQL 的 **InnoDB 存储引擎采用两段锁协议**，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

## 1.5 三大范式

第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。

第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。

第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y

# 2 MySQL

## 2.1 数据类型

**整型**：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

**浮点数**：FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

**字符串**：主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

**时间和日期**：MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。

- `DATETIME`：能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。它与**时区无关**。
- `TIMESTAMP`：和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。

## 2.2 索引

索引（Index）：**索引也叫键，是存储引擎用于快速找到记录的一种数据结构**。索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但数据量逐渐增大时，性能会急剧下降。

### 2.2.1 索引分类（物理存储）

MySQL索引按照叶子节点存储是否为完整表数据分为**聚簇索引**和**二级索引（辅助索引）**。

（1）聚簇索引

聚簇索引的每个**叶子节点**存储了**一行完整的表数据**，叶子节点间按照id列递增连接，可以方便地进行顺序检索。

<img src="D:\Desktop\PlanBrick\CPP\interview\pics\jcsy.jpg" style="zoom:67%;" />

InnoDB表要求**必须有聚簇索引**，默认在**主键字段**上建立聚簇索引，在没有主键字段的情况下，表的第一个**非空的唯一索引**将被建立为聚簇索引，在前两者都没有的情况下，InnoDB将自动生成一个**隐式的自增id列**，并在此列上建立聚簇索引。

以MyISAM为存储引擎的表不存在聚簇索引。

MyISAM表中的主键索引和非主键索引的结构是一样的，索引的叶子节点不存储表数据，存放的是表数据的地址。所以，MyISAM表可以没有主键。

<img src="D:\Desktop\PlanBrick\CPP\interview\pics\myisam.jpg" style="zoom:67%;" />

MyISAM表的数据和索引是分开存储的。MyISAM表的主键索引和非主键索引的区别仅在于主键索引的B+tree上的key必须符合主键的限制，非主键索引B+tree上的key只要符合相应字段的特性就可以了。

（2）二级索引

辅助索引，或者非聚簇索引。二级索引的叶子节点并不储存一行完整的数据，只是储存了主键的值。

<img src="D:\Desktop\PlanBrick\CPP\interview\pics\ejsy.jpg" style="zoom:67%;" />

由于二级索引的叶子节点不储存完整的表数据，当通过二级索引查询到相应聚簇索引列值后，还需要回到聚簇索引也就是表数据本身进一步获取数据，这一过程称为**回表查询**。

![](D:\Desktop\PlanBrick\CPP\interview\pics\hbcx.jpg)

回表查询 需要额外的 **B+tree** 搜索过程，必然增大查询耗时。

需要注意的是，**通过二级索引查询时，回表不是必须的过程**，当**SELECT的所有字段在单个二级索引中都能够找到**时，就不需要回表，MySQL称此时的二级索引为**覆盖索引**或触发了**索引覆盖**。 可以用Explain命令查看SQL语句的执行计划，执行计划的Extra字段中若出现**Using index**，表示查询触发了**索引覆盖**。



索引按照**字段特性**分类可以分为：

- 主键索引：建立在主键上的索引。一张表只能有一个主键索引，索引列值不允许有空值。
- 唯一索引：建立在UNIQUE字段上的索引被称为唯一索引。一张表可以有多个唯一索引，允许列值为空。
- 普通索引：建立在普通字段上的索引被称为普通索引。
- 前缀索引：对字符类型的字段的前几个字符或二进制类型的前几个bytes建立的索引，而不是在整个字段上建立索引。

索引按照**字段个数**分类可以分为：

- 单列索引：建立在单列上的索引。
- 联合索引（复合索引、组合索引）：建立在多个列上的索引。

### 2.2.2 索引的使用条件

- 对于比较小的表，大部分情况下简单的全表扫描比建立索引更高效。
- 对于中到大型的表，可以考虑建立索引。
- 对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用**分区技术**。

### 2.2.3 索引采用的数据结构（分类）

（1）B+Tree

MySQL的默认索引类型。

- InnoDB存储引擎的[最小存储单元是页](https://www.jianshu.com/p/0aba6d552a55)，页的默认大小是16Kb（16 * 1024字节），页可以用于存放数据也可以用于存放键值+指针。在B+树中叶子节点存放数据，非叶子节点存放键值+指针。
- 索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；

B+Tree与**红黑树**相比：

红黑树是一种**弱平衡二叉查找树**，通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，**确保没有一条路径会比其他路径长出两倍**。

对于有N个叶子结点的 **B+tree**，其搜索复杂度为 `O(logdN)` ，其中 **d**(degree) 为 **B+tree** 的度，表示节点允许的最大子节点个数为**d**个，在实际应用当中，**d**值一般是大于100的，即使数据量达到千万级别时**B+tree**的高度依然维持在3-4左右，保证了3-4次磁盘I/O操作就能查询到目标数据。

**红黑树**是二叉树，节点子节点个数为两个，意味着其搜索复杂度为 `O(logN)`，树的高度也会比 **B+tree** 高出不少，因此**红黑树**检索到目标数据所需经历的磁盘I/O次数更多。

因为当 MySQL 数据量很大的时候，索引的体积也会很大，可能内存放不下，所以需要从磁盘上进行相关读写，如果树的层级太高，则读写磁盘的次数（I/O交互）就会越多，**性能就会越差**。

（2）哈希表

就是把任意值(key)通过哈希函数变换为固定长度的 key 地址，通过这个地址进行具体数据的数据结构。哈希表查找的时间复杂度为O(1)。

缺点：

- 无法用于排序和分组。
- 只支持精确查找，无法用于部分查找和范围查找。
- 哈希碰撞

（3）全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

（4）空间数据索引

MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

## 2.3 索引优化

（1）独立的列

在查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

（2）多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能要好。

（3）索引列的顺序

让选择性最强的索引列放在前面。索引的选择性是指不重复的索引值和记录总数的比值，最大值为1。

## 2.4 查询优化

### 2.4.1 使用Explain进行分析

Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。

比较重要的字段有：

- select_type : 查询类型，有简单查询、联合查询、子查询等
- key : 使用的索引
- rows : 扫描的行数

### 2.4.2 优化数据访问

（1）减少请求的数据量

- 只返回必要的列：最好不要使用 SELECT * 语句。
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
- 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。

（2）减少服务器端扫描的行数，考虑使用索引。

（3）重构查询方式

切分大查询：一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

分解大连接查询：将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：

## 2.5 MySQL引擎

### 2.5.1 InnoDB

InnoDB是MySQL**默认的事务型引擎**，也是最重要、最广泛的存储引擎。它的设计是用来处理大量短期事务，短期事务大部分是正常提交的，很少回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中，也很流行。除了非常特别的原因需要使用其他引擎，InnoDB也是非常好值得花时间研究的对象。

InnoDB默认的事务隔离级别为可重复度，通过MVCC（多版本并发控制）来实现的。

InnoDB通过**间隙锁**（next-key locking）防止**幻读**的出现。InnoDB是基于**聚簇索引**建立，与其他存储引擎有很大的区别，聚簇索引对主键查询有很高的性能，不过它的二级索引（secondary index，非主键索引）必须包含主键列。所以如果主键列很大的话，索引会很大。

### 2.5.2 MyISAM

在5.1之前，MyISAM是默认的引擎，MyISAM有大量的特性，包括**全文索引**、**压缩表**、**空间函数**。但是MyISAM**不支持行级锁**，而且在崩溃后无法安全恢复。

### 2.5.3 MEMORY

memory存储引擎相比前面的一些存储引擎，有点不一样，其使用存储在内存中的数据来创建表，而且所有的数据也都存储在内存中。

每个基于memory存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为.frm。该文件只存储表的结构，而其数据文件，都是存储在内存中，这样有利于对数据的快速处理，提高整个表的处理能力。

memory存储引擎默认使用哈希（HASH）索引，其速度比使用B-+Tree型要快，如果读者希望使用B树型，则在创建的时候可以引用。

memory存储引擎文件数据都存储在内存中，如果mysqld进程发生异常，重启或关闭机器这些数据都会消失。所以memory存储引擎中的表的生命周期很短，一般只使用一次。

### 2.5.4 ARCHIVE

该存储引擎非常适合存储大量独立的、作为历史记录的数据。区别于InnoDB和MyISAM这两种引擎，ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差一些。

# 3 Redis

## 3.1 概述

Redis是速度非常快的非关系型（NoSQL）内存键值数据库。**键的类型只能为字符串**，而值的类型有五种。

Redis 服务器是一个**事件驱动程序**。

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。

## 3.2 值数据类型

| 数据类型 |      可以存储的值      |                             操作                             |
| :------: | :--------------------: | :----------------------------------------------------------: |
|  STRING  | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作 |
|   LIST   |          列表          | 从两端压入或者弹出元素 </br> 对单个或者多个元素进行修剪，</br> 只保留一个范围内的元素 |
|   SET    |        无序集合        | 添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素 |
|   HASH   | 包含键值对的无序散列表 | 添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在 |
|   ZSET   |        有序集合        | 添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名 |

## 3.3 数据结构

### 3.3.1 字典

dictht 是一个哈希表结构，使用**开链法**解决哈希冲突。

Redis的字典dict中包含两个哈希表dictht，这是为了方便进行rehash操作。在扩容时，将一个dictht上的键值对rehash到另一个dictht，完成之后释放空间并交换两个dictht的角色。

```c++
typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */
    unsigned long iterators; /* number of iterators currently running */
} dict;
```

### 3.3.2 跳跃表

有序集合的底层实现之一。跳跃表是基于多指针有序链表实现的，可以看作是多个有序链表

![](D:\Desktop\PlanBrick\CPP\interview\pics\tyb.png)

例如寻找22：

![](D:\Desktop\PlanBrick\CPP\interview\pics\tyb22.png)

优点：

- 插入速度非常快。因为不需要进行旋转等操作来维护平衡性
- 容易实现
- 支持无锁操作

## 3.4 键的过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。

## 3.5 数据淘汰策略

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

|      策略       |                         描述                         |
| :-------------: | :--------------------------------------------------: |
|  volatile-lru   | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 |
|  volatile-ttl   |   从已设置过期时间的数据集中挑选将要过期的数据淘汰   |
| volatile-random |      从已设置过期时间的数据集中任意选择数据淘汰      |
|   allkeys-lru   |       从所有数据集中挑选最近最少使用的数据淘汰       |
| allkeys-random  |          从所有数据集中任意选择数据进行淘汰          |
|   noeviction    |                     禁止驱逐数据                     |

## 3.6 持久化

Redis是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。

### 3.6.1 RDB持久化

将某个时间点的所有数据都存放在硬盘上。

可以将快照复制到其它服务器上从而创建具有相同数据的服务器副本。

如果系统发生故障，将会丢失最后一次创建快照之后的数据。

如果数据量很大，保存快照的时间会很长。

### 3.6.2 AOF持久化

将写命令添加到AOF文件（Append Only File）的末尾。

使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：

|   选项   |         同步频率         |
| :------: | :----------------------: |
|  always  |     每个写命令都同步     |
| everysec |       每秒同步一次       |
|    no    | 让操作系统来决定何时同步 |

- always 选项会严重减低服务器的性能；
- everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
- no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。

另外，随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

## 3.7 事件

Redis是一个事件驱动程序。

### 3.7.1文件事件

服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。

Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。

![](D:\Desktop\PlanBrick\CPP\interview\pics\wjsj.png)

### 3.7.2 时间事件

服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。

时间事件又分为：

- 定时事件：是让一段程序在指定的时间之内执行一次；
- 周期性事件：是让一段程序每隔指定时间就执行一次。

Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。

### 3.7.3 事件调度与执行

服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。

事件调度与执行由 aeProcessEvents 函数负责。

从事件处理的角度来看，服务器运行流程如下：

<img src="D:\Desktop\PlanBrick\CPP\interview\pics\sjdd.png" style="zoom:50%;" />
